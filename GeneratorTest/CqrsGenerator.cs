using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using Microsoft.CodeAnalysis;

#pragma warning disable RS1035 // Do not use banned APIs for analyzers

namespace NForza.Cqrs;

[Generator]
public class CqrsGenerator : ISourceGenerator
{
    public void Execute(GeneratorExecutionContext context)
    {
#if DEBUG
        //This will launch the debugger when the generator is running
        //You might have to do a Rebuild to get the generator to run
        if (!Debugger.IsAttached)
        {
            Debugger.Launch();
        }
#endif
        var additionalFile = context.AdditionalFiles
            .FirstOrDefault(file => Path.GetFileName(file.Path) == "cqrsConfig.json");

        string jsonConfigContent = additionalFile.GetText(context.CancellationToken)?.ToString() ?? string.Empty;
        var configuration = JsonSerializer.Deserialize<Configuration>(jsonConfigContent);
        var contractSuffix = configuration.Contracts.ProjectSuffix;
        var commandSuffix = configuration.Commands.CommandSuffix;
        var methodHandlerName = configuration.Commands.HandlerMethodName;

        var commands = GetAllCommandsFromContractsAssembly(context.Compilation, contractSuffix, commandSuffix).ToList();
        var handlers = context.Compilation
            .GetSymbolsWithName(s => s == methodHandlerName, SymbolFilter.Member)
            .OfType<IMethodSymbol>()
            .Where(m => m.Parameters.Length == 1 && commands.Contains(m.Parameters[0].Type, SymbolEqualityComparer.Default))
            .ToList();

        foreach (var command in commands.OfType<ITypeSymbol>())
        {
            Debug.WriteLine($"Found command: {command.Name}");
        }

        foreach (var handlerType in handlers.OfType<IMethodSymbol>().Select(m => m.ContainingType))
        {
            Debug.WriteLine($"Found handler: {handlerType.Name}");
        }

        GenerateCommandProcessorInterface(context, handlers);

        GenerateCommandProcessorImplementation(context, handlers);

        GenerateServiceCollectionExtensions(context, handlers);
    }

    private IEnumerable<INamedTypeSymbol> GetAllCommandsFromContractsAssembly(Compilation compilation, string contractProjectSuffix, string commandSuffix)
    {
        foreach (var reference in compilation.References)
        {
            var assemblySymbol = compilation.GetAssemblyOrModuleSymbol(reference) as IAssemblySymbol;
            if (assemblySymbol == null || !assemblySymbol.Name.EndsWith(contractProjectSuffix)) continue;

            // Recursively find all types in the assembly
            var allTypes = GetAllTypes(assemblySymbol.GlobalNamespace);

            // Example: Filter types or perform additional logic
            foreach (var type in allTypes.OfType<INamedTypeSymbol>().Where(t => t.IsRecord))
            {
                if (type.Name.EndsWith(commandSuffix))
                {
                    yield return type;
                }
            }
        }
    }

    private IEnumerable<INamedTypeSymbol> GetAllTypes(INamespaceSymbol namespaceSymbol)
    {
        // Recursively find all types in the namespace and its nested namespaces
        foreach (var member in namespaceSymbol.GetMembers())
        {
            if (member is INamespaceSymbol nestedNamespace)
            {
                // Recursively get types in the nested namespace
                foreach (var nestedType in GetAllTypes(nestedNamespace))
                {
                    yield return nestedType;
                }
            }
            else if (member is INamedTypeSymbol namedType)
            {
                // Yield the found type
                yield return namedType;
            }
        }
    }


    private void GenerateServiceCollectionExtensions(GeneratorExecutionContext context, List<IMethodSymbol> handlers)
    {
        StringBuilder source = new StringBuilder();
        source.Append($@"// <auto-generated/>
using System;
using Microsoft.Extensions.DependencyInjection;

namespace NForza.Cqrs;

public static class ServiceCollectionExtensions
{{
    public static IServiceCollection AddCqrs(this IServiceCollection services)
    {{
        services.AddSingleton<ICommandProcessor, CommandProcessor>();");
        foreach (var typeToRegister in handlers.OfType<IMethodSymbol>().Select(h => h.ContainingType).Distinct(SymbolEqualityComparer.Default))
        {
            source.Append($@"
        services.AddTransient<{typeToRegister.ToDisplayString()}>();");
        }

        source.Append($@"
        return services;
    }}
}}
");
        context.AddSource($"ServiceCollectionExtensions.g.cs", source.ToString());
    }

    private static void GenerateCommandProcessorImplementation(GeneratorExecutionContext context, List<IMethodSymbol> handlers)
    {
        StringBuilder source = new StringBuilder();
        source.Append($@"// <auto-generated/>
using System;
using Microsoft.Extensions.DependencyInjection;

namespace NForza.Cqrs;

public class CommandProcessor(IServiceProvider serviceProvider): ICommandProcessor
{{");
        foreach (var handler in handlers)
        {
            var methodSymbol = handler as IMethodSymbol;
            var handlerReturnType = methodSymbol.ReturnType;
            var parameterType = methodSymbol.Parameters[0].Type;
            var typeSymbol = methodSymbol.ContainingType;
            source.Append($@"
    public {handlerReturnType.ToDisplayString()} Execute({parameterType} command) 
        => serviceProvider.GetRequiredService<{handler.ContainingType.ToDisplayString()}>().Execute(command);

");
        }

        source.Append($@"
}}
");
        context.AddSource($"CommandProcessor.g.cs", source.ToString());
    }

    private static void GenerateCommandProcessorInterface(GeneratorExecutionContext context, List<IMethodSymbol> handlers)
    {
        StringBuilder source = new StringBuilder();
        source.Append($@"// <auto-generated/>
using System;

namespace NForza.Cqrs;

public interface ICommandProcessor
{{");
        foreach (var handler in handlers)
        {
            var methodSymbol = handler as IMethodSymbol;
            var handlerReturnType = methodSymbol.ReturnType;
            var parameterType = methodSymbol.Parameters[0].Type;
            var typeSymbol = methodSymbol.ContainingType;
            source.Append($@"
    {handlerReturnType.ToDisplayString()} Execute({parameterType} command);");
        }
        source.Append($@"
}}
");
        context.AddSource($"ICommandProcessor.g.cs", source.ToString());
    }

    public void Initialize(GeneratorInitializationContext context)
    {
    }
}